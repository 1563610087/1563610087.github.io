(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{383:function(t,n,e){"use strict";e.r(n);var s=e(42),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-进阶"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-进阶"}},[t._v("#")]),t._v(" react 进阶")]),t._v(" "),e("h1",{attrs:{id:"_1-hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-hook"}},[t._v("#")]),t._v(" 1 hook")]),t._v(" "),e("p",[e("em",[t._v("Hook")]),t._v(" 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性")]),t._v(" "),e("p",[e("strong",[t._v("Hook 使你在无需修改组件结构的情况下复用状态逻辑")])]),t._v(" "),e("p",[e("strong",[t._v("Hook 使你在非 class 的情况下可以使用更多的 React 特性")])]),t._v(" "),e("p",[e("strong",[t._v("什么时候我会用 Hook？")]),t._v(" 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。")]),t._v(" "),e("h3",{attrs:{id:"_1-1-定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-定义"}},[t._v("#")]),t._v(" 1.1 定义")]),t._v(" "),e("p",[t._v("Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React，下面为两种方式的对比。")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState, useEffect } from 'react';\nclass App extends React.Component{\n  constructor() {\n    super()\n    this.state = {\n      count:1\n    }\n  }\n  render() {\n    const count = this.state.count\n    return (\n      <div>\n        <p>You clicked {count} times</p>\n        <button onClick={()=>this.setState({count:count+1})}>点击</button>\n      </div>\n    )\n  }\n}\nexport default App\n\n\n")])])]),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState, useEffect } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\nexport default App\n")])])]),e("h3",{attrs:{id:"_1-2-usestate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-usestate"}},[t._v("#")]),t._v(" 1.2 useState")]),t._v(" "),e("p",[t._v("例子")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState, useEffect } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\nexport default App\n")])])]),e("p",[e("strong",[t._v("const [count, setCount] = useState(0)")])]),t._v(" "),e("p",[t._v("表示设置一个state变量，变量名为count，setcount为一个函数，这个函数可以改变count的值，类似this.setState")]),t._v(" "),e("p",[t._v("useState可以给变量count设置初始值，这里设置的是0，useState()方法接受的参数就是初始的state")]),t._v(" "),e("p",[t._v("useState()方法它返回一个有两个值的数组。第一个值是当前的 state，第二个值是更新 state 的函数，这里采用方括号定义了一个 state 变量，这是因为采用数组的结构赋值，将返回的数组的元素赋值这两个变量。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("设置多个state")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function ExampleWithManyStates() {\n  // 声明多个 state 变量\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: '学习 Hook' }]);\n")])])])]),t._v(" "),e("li",[e("p",[t._v("更新state")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//直接采用setCount更新state \n<button onClick={() => setCount(count + 1)}>\n    Click me\n  </button>\n")])])])])]),t._v(" "),e("h3",{attrs:{id:"_1-3-useeffect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-useeffect"}},[t._v("#")]),t._v(" 1.3 useEffect")]),t._v(" "),e("p",[t._v("数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用")]),t._v(" "),e("p",[t._v("把 "),e("code",[t._v("useEffect")]),t._v(" Hook 看做 "),e("code",[t._v("componentDidMount")]),t._v("，"),e("code",[t._v("componentDidUpdate")]),t._v(" 和 "),e("code",[t._v("componentWillUnmount")]),t._v(" 这三个函数的组合")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // Similar to componentDidMount and componentDidUpdate:\n  useEffect(() => {\n    // Update the document title using the browser API\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n")])])]),e("p",[t._v("react中有两种常见副作用操作：需要清除的和不需要清除的。我们来更仔细地看一下他们之间的区别。")]),t._v(" "),e("p",[e("strong",[t._v("1 无需清除的effect")]),t._v("\n有时候，我们只想**在 React 更新 DOM 之后运行一些额外的代码。**比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//在类组件中，我们需要在初次渲染和更新两个阶段调用相同的代码，造成代码的重复\n\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n")])])]),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//在hook中，只需要使用一次useEffect即可\n\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n")])])]),e("p",[t._v("useEffect会在每次渲染后执行，包括第一次渲染和更新之后的渲染。将useEffect放在组件内部可以直接访问到state变量，变量在函数作用域中。")]),t._v(" "),e("p",[e("strong",[t._v("2 需要清除effect")])]),t._v(" "),e("p",[t._v("在 React class 中，你通常会在 "),e("code",[t._v("componentDidMount")]),t._v(" 中设置订阅，并在 "),e("code",[t._v("componentWillUnmount")]),t._v("中清除它。例如，假设我们有一个 "),e("code",[t._v("ChatAPI")]),t._v(" 模块，它允许我们订阅好友的在线状态。以下是我们如何使用 class 订阅和显示该状态：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//在类组件中\nclass FriendStatus extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n\n  render() {\n    if (this.state.isOnline === null) {\n      return 'Loading...';\n    }\n    return this.state.isOnline ? 'Online' : 'Offline';\n  }\n}\n")])])]),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//使用hook\nimport React, { useState, useEffect } from 'react';\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // Specify how to clean up after this effect:\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n")])])]),e("p",[t._v("在useEffect中返回一个函数，这是effect可选的清除机制，组件会在卸载的时候执行清除操作，调用这个函数。每次数据更新会先调用return返回的函数进行清除，然后执行函数内的内容")]),t._v(" "),e("p",[e("strong",[t._v("effect性能优化")])]),t._v(" "),e("p",[t._v("effect每次重新渲染就会调用函数，这就会导致性能问题，所以useEffect可以传入第二个参数")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 仅在 count 更改时更新\n")])])]),e("p",[t._v("上面这个示例中，我们传入 "),e("code",[t._v("[count]")]),t._v(" 作为第二个参数。这个参数是什么作用呢？如果 "),e("code",[t._v("count")]),t._v("的值是 "),e("code",[t._v("5")]),t._v("，而且我们的组件重渲染的时候 "),e("code",[t._v("count")]),t._v(" 还是等于 "),e("code",[t._v("5")]),t._v("，React 将对前一次渲染的 "),e("code",[t._v("[5]")]),t._v(" 和后一次渲染的 "),e("code",[t._v("[5]")]),t._v(" 进行比较。因为数组中的所有元素都是相等的("),e("code",[t._v("5 === 5")]),t._v(")，React 会跳过这个 effect，这就实现了性能的优化。")]),t._v(" "),e("p",[t._v("如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（"),e("code",[t._v("[]")]),t._v("）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。")]),t._v(" "),e("h3",{attrs:{id:"_1-4-使用规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-使用规则"}},[t._v("#")]),t._v(" 1.4 使用规则")]),t._v(" "),e("h3",{attrs:{id:"_1-5-自定义hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-自定义hook"}},[t._v("#")]),t._v(" 1.5 自定义hook")]),t._v(" "),e("h3",{attrs:{id:"_1-6-采用hook和类组件的对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-采用hook和类组件的对比"}},[t._v("#")]),t._v(" 1.6 采用hook和类组件的对比")])])}),[],!1,null,null,null);n.default=a.exports}}]);